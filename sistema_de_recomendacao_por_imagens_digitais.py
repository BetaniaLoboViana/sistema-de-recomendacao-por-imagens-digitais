# -*- coding: utf-8 -*-
"""sistema de recomendacao por imagens digitais.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1REeMJGFxcRXHXqdrLcDeN4lk-5wPaLok
"""

from google.colab import drive
drive.mount('/content/drive')  # Caso deseje usar imagens salvas no Drive

import os

# Caminho até a pasta que contém as imagens
path_to_images = '/produtos'

# Verificar se a pasta existe
os.listdir(path_to_images)

from tensorflow.keras.preprocessing import image
import numpy as np

# Caminho de uma imagem dentro da pasta
img_path = '/produtos/bike.jpg'

# Carregar e processar a imagem
img = image.load_img(img_path, target_size=(224, 224))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)

!pip install tensorflow keras opencv-python numpy matplotlib

from tensorflow.keras.applications import VGG16
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import preprocess_input
import numpy as np
import os
import cv2

# Carregar o modelo VGG16 pré-treinado
model = VGG16(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Extrair as características de uma imagem
def extract_features(img_path):
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)

    features = model.predict(img_array)
    return features.flatten()

# Caminho para as imagens
image_dir = '/produtos'  # caminho das imagens

# Extrair as características de todas as imagens em uma pasta
features_list = []
image_paths = []

for img_name in os.listdir(image_dir):
    img_path = os.path.join(image_dir, img_name)
    features = extract_features(img_path)
    features_list.append(features)
    image_paths.append(img_path)

# Converter para array numpy
features_array = np.array(features_list)

from scipy.spatial.distance import cosine
from sklearn.metrics.pairwise import cosine_similarity

def calculate_similarity_multiple(*features_list):
    # Calcular similaridade entre múltiplas imagens
    similarities = []
    for i in range(len(features_list)):
        for j in range(i+1, len(features_list)):
            # Formato  2D
            similarity = cosine_similarity(features_list[i].reshape(1, -1), features_list[j].reshape(1, -1))
            similarities.append(similarity)
    return similarities

# Comparação entre imagens
img1_features = extract_features('/produtos/bike.jpg')
img2_features = extract_features('/produtos/bike1.jpg')
img3_features = extract_features('/produtos/bike3.jpg')
img4_features = extract_features('/produtos/celular.jpg')
img5_features = extract_features('/produtos/celular1.jpg')
img6_features = extract_features('/produtos/celular3.jpg')
img7_features = extract_features('/produtos/relogio.jpg')
img8_features = extract_features('/produtos/relogio1.jpg')
img9_features = extract_features('/produtos/relogio3.jpg')
img10_features = extract_features('/produtos/notebook.jpg')
img11_features = extract_features('/produtos/notebook1.jpg')
img12_features = extract_features('/produtos/notebook3.jpg')

similarities = calculate_similarity_multiple(img1_features, img2_features, img3_features, img4_features, img5_features, img6_features, img7_features, img8_features, img9_features, img10_features, img11_features, img12_features)

# Exibindo as similaridades calculadas
for idx, sim in enumerate(similarities):
    print(f'Similaridade {idx+1}: {sim}')

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

def recommend_similar_images(input_img_path, features_array, image_paths, top_n=3):
    # Extrair as características da imagem de entrada
    input_img_features = extract_features(input_img_path)

    similarities = []

    # Calcular similaridade entre a imagem de entrada e as outras
    for i, features in enumerate(features_array):
        similarity = calculate_similarity(input_img_features, features)
        similarities.append((similarity, image_paths[i]))

    # Ordenar as imagens pela similaridade (da mais semelhante para a menos semelhante)
    similarities.sort(key=lambda x: x[0])

    # Retornar as top_n imagens mais semelhantes (excluindo a imagem de entrada)
    recommended_images = [image_path for _, image_path in similarities[:top_n]]

    return recommended_images

# Mostrar as imagens recomendadas lado a lado para cada imagem de entrada
def show_all_recommended_images(input_images, features_array, image_paths, top_n=3):
    # Figura com múltiplas linhas, uma para cada imagem de entrada
    num_images = len(input_images)
    fig, axes = plt.subplots(num_images, top_n + 1, figsize=(10, 3 * num_images))

    for i, input_image in enumerate(input_images):
        recommended_images = recommend_similar_images(input_image, features_array, image_paths, top_n)

        # Exibir a imagem de entrada
        img_input = mpimg.imread(input_image)
        axes[i, 0].imshow(img_input)
        axes[i, 0].axis('off')
        axes[i, 0].set_title(f'Imagem de Entrada {i+1}')

        # Exibir as imagens recomendadas
        for j, img_path in enumerate(recommended_images):
            img = mpimg.imread(img_path)
            axes[i, j+1].imshow(img)
            axes[i, j+1].axis('off')
            axes[i, j+1].set_title(f'Recomendada {j+1}')

    plt.tight_layout()
    plt.show()

# Lista de imagens de entrada
input_images = [
    '/produtos/bike.jpg',
    '/produtos/celular.jpg',
    '/produtos/relogio.jpg',
    '/produtos/notebook.jpg'

]

# Exibir asimagens mais recomendadas para todas as imagens de entrada
show_all_recommended_images(input_images, features_array, image_paths, top_n=3)

